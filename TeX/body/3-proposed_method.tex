% the proposed method section...

\chapter{روش پیشنهادی} \label{chapter:proposed-method}

\paragraph*{}
این فصل به بیان روش پیشنهادی می‌پردازد؛ ولی قبل از بیان روش، مسئله‌ای که حل آن هدف این پایان‌نامه است، به درستی و کامل بیان گردد. پس در ابتدای فصل به بیان صورت مسئله پرداخته می‌شود.

\section{صورت مسئله}

\paragraph*{}
در این قسمت ابتدا به بیان تعاریف اولیه در رابطه با سامانه‌ی ذخیره‌ای داده‌ی توزیعی و ورودی‌ها و خروجی‌های آن پرداخته می‌شود و سپس تعریف دقیقی از صورت مسئله‌ای که حل آن هدف این پایان‌نامه است، ارائه می‌گردد. همانطور که گفته شد، یک پایگاه‌داده‌ی توزیعی از یک لایه‌ی سرویس‌دهنده‌ی نرم‌افزاری و همچنین از تعداد سرویس‌دهنده‌های پایگاه‌داده‌ی فیزیکی تشکیل می‌شود. در این مسئله فرض می‌شود که مجموعه‌ی
\lr{$ \servers $}
همان سرویس‌دهنده‌های پایگاه‌داده‌ی سامانه‌ی توزیعی است که چندتایی‌های داده را درون خود نگهداری می‌نمایند.

\begin{latin}
	\begin{equation} \label{equation:servers}
		\servers = \left \{ \server_{1}, \server_{2}, ..., \server_{\numberOfServers} \right \}
	\end{equation}
\end{latin}

\paragraph*{}
که در رابطه‌ی
\ref{equation:servers}،
مقدار
\lr{$ \numberOfServers $}
عبارتست از تعداد سرویس‌دهنده‌ی پایگاه‌داده. همچنین می‌دانیم که درون هر یک از این سرویس‌دهنده‌های پایگاه‌داده، می‌توان مجموعه‌ای از چند‌تایی‌هایی از داده‌های رابطه‌ای ذخیره گردد که حداکثر تعداد این چند‌تایی‌ها می‌تواند
\lr{$ \numberOfTuples $}
باشد. در واقع این مقدار، حداکثر تعداد چند‌تایی‌هایی است که می‌توان درون یک سرویس‌دهنده‌ی فیزیکی گنجاند. مجموعه‌ی چند‌تایی‌ها در رابطه‌ی
\ref{equation:tuples}
دیده می‌شود.

\begin{latin}
	\begin{equation} \label{equation:tuples}
		\tuples = \left \{ \tuple_{1}, \tuple_{2}, ..., \tuple_{\numberOfTuples} \right \}
	\end{equation}
\end{latin}

\paragraph*{}
اکنون به تعریف ورودی‌ها و خروجی‌های سامانه پرداخته می‌شود. همانطور که گفته شد، در پایگاه‌های داده‌ی رابطه‌ای، تراکنش عبارتست از واحد انجام عملیاتی که طی ورود آن به سامانه‌ی پایگاه‌داده یا به طور کلی اجرا می‌شود و یا هیچ یک از اجزای آن اجرا نخواهد شد. هر جزئی از تراکنش کوچک‌ترین اجزای پایگاه‌داده، یعنی چندتایی‌ها را تحت تأثیر قرار می‌دهند و مجموعه‌ی کل چند‌تایی‌هایی که متأثر قرار می‌گیرند، خروجی‌های سامانه را که همان خروجی‌های اجرای تراکنش‌های ورودی است، ایجاد می‌کنند. در حقیقت توزیعی بودن کل سامانه‌ی پایگاه‌داده می‌بایست از دید کاربر به طور کامل پنهان باشد.

\paragraph*{}
مجموعه‌ی کل تراکنش‌هایی که هر یک از آن‌ها حداقل یک مرتبه به سامانه وارد شده‌اند، در معادله‌ی
\ref{equation:transactions}
نشان داده شده است؛ که تعداد آن‌ها
\lr{$ \numberOfTransactions $}
فرض شده است. ولی چیزی که در الگوریتم بخش‌بندی داده‌های درون سامانه توزیعی اهمیت دارد، بخش‌بندی بر اساس ورودی‌های أخیر
\LTRfootnote{Recent}
است. پس باید مکانیزمی برای فراموش کردن ورودی‌های قدیمی‌تر ایجاد نمود.
\begin{latin}
	\begin{equation} \label{equation:transactions}
		\transactions = \left \{ \transaction_{1}, \transaction_{2}, ...,\transaction_{\numberOfTransactions} \right \}
	\end{equation}
\end{latin}


\paragraph*{}
همانطور که در بخش
\ref{chapter:related-works}
نیز گفته شد، بخش‌بندی که برای چنین سامانه‌ای انجام می‌گیرد، می‌بایست با حجم کار کنونی (در اینجا می‌توان از مفهوم أخیر نیز استفاده نمود) منطبق باشد و ورودی‌هایی که در گذشته وارد سامانه شده‌اند را در بخش‌بندی کنونی مد نظر قرار ندهد. برای اعمال مکانیزمی برای مستهلک کردن داده‌هایی که برای سامانه، داده‌های أخیر بشمار نمی‌آیند، مقدار
\lr{$ \window $}
تعریف می‌شود که عبارتست از تعدادی از آخرین تراکنش‌های ورودی به سامانه که در الگوریتم بخش‌بندی دارای اهمیت تلقی می‌شوند. بدیهی است که تراکنش‌هایی که خارج از این پنجره قرار گیرند، هیچ گونه تأثیری در الگوریتم بخش‌بندی نخواهند داشت. پس می‌توان گفت که از این پس هر گاه عبارت تراکنش گفته شد، منظور همان تراکنش‌هایی است که در پنجره ظاهر شده‌اند و تراکنش أخیر به حساب می‌آیند.

\paragraph*{}
مجموعه‌ی تراکنش‌های
\lr{$ \distributedTransactions $}
تراکنش‌های توزیعی در هر مقطع زمانی از سامانه هستند و مجموعه‌ی
\lr{$ \nonDistributedTransactions $}
تراکنش‌های غیر توزیعی (محلی) هستند که تمامی آن‌ها درون هر سرویس‌دهنده پاسخ داده می‌شوند. لازم به ذکر است که کل تراکنش‌های ورودی سامانه از اجتماع این دو تشکیل می‌شود (معادله‌ی
\ref{equation:transactions-union})
و هر تراکنش در آن واحد می‌تواند فقط و فقط یکی از این دو حالت را داشته باشد (معادله‌ی
\ref{equation:transactions-intersection}).
یا به عبارتی:

\begin{latin}
	\begin{equation} \label{equation:transactions-union}
		\distributedTransactions \cup \nonDistributedTransactions = \transactions
	\end{equation}
\end{latin}

\begin{latin}
	\begin{equation} \label{equation:transactions-intersection}
		\distributedTransactions \cap \nonDistributedTransactions = \emptyset
	\end{equation}
\end{latin}

\paragraph*{}
به طور معمول در تعریف سامانه‌های ذخیره‌ای داده‌ی توزیعی، فرض ساده کننده‌ای می‌شود که طی آن ظرفیت گره‌های سرویس‌دهنده یکسان فرض می‌شود و نرخ توزیع غیر همسان بار
\LTRfootnote{Imbalance Ratio}،
اختلاف میان بیشینه بار میان سرویس‌دهنده‌ها و کمینه مقدار بار موجود در میان سرویس‌دهنده‌ها تعریف می‌شود. برای تعریف این مؤلفه در اینجا نیاز است که مؤلفه‌ی دیگری به نام نسبت اشغال بودن سرویس‌دهنده که این مؤلفه عبارتست از نسبت ظرفیتی از سرویس‌دهنده که اشغال است، به میزان ظرفیت کل سرویس‌دهنده.

\paragraph*{}
با تعریف جدید می‌توان فرض مساوی بودن ظرفیت سرویس‌دهنده‌ها را نادیده گرفت. اکنون طبق این تعریف، نرخ توزیع غیر همسان بار عبارتست از اختلاف میان بیشینه نسبت اشغال بودنِ پُر ترین سرویس‌دهنده به نسبت اشغال بودنِ خالی‌ترین سرویس‌دهنده. لازم به ذکر است که این کمیت با
\lr{$ \imbalanceRatio $}
نشان داده می‌شود.

\paragraph*{}
صورت مسئله‌ای که قصد حل آن وجود دارد عبارتست از: با پنجره‌ی تراکنش
\lr{$ \window $}
و مجموعه‌ی
\lr{$ \numberOfServers $}
سرویس‌دهندگان پایگاه‌داده‌ی
\lr{$ \servers $}
که هر یک می‌توانند شامل
\lr{$ \numberOfTuples $}
چندتایی داده باشند، همچنین با تعریف میزان غیر همسان توزیع شدن بار
\lr{$ \imbalanceRatio $}،
مطلوب است الگوریتم بخش‌بندی متوازن
\lr{$ \clusteringAlgorithm $}
به نحوی که تعداد تراکنش‌های توزیعی در کل سامانه، کمینه گردد و همچنین در انجام الگوریتم بخش‌بندی، کمینه تعداد جابجایی‌های بین سرویس‌دهنده‌ها صورت گیرد.

\section{مدل حجم کار}

\paragraph*{}
همانطور که در بخش
\ref{chapter:related-works}
نیز گفته شد، به منظور بخش‌بندی داده‌های ذخیره شده در یک پایگاه‌داده رابطه‌ای، به طور معمول داده‌ها را به یک گراف مدل می‌کنند. روش معمول به این صورت است که برای سادگی کل پایگاه‌داده به یک جدول بسیار بزرگ مدل می‌شود؛ به صورتی که هر یک از اشیائی که تحت عنوان چندتایی درون پایگاه‌داده‌ی بزرگ ذخیره شده‌اند، با یک شناسه‌ی یکتا در کل پایگاه‌داده، شناسایی و مشخص می‌شود. در واقع کل شمای پایگاه‌داده برای سادگی به یک جدول بسیار بزرگ با اشیایی که با شناسه مشخص شده‌اند مدل خواهد شد.

\paragraph*{}
اکنون این پایگاه‌داده‌ی بسیار بزرگ به گراف وزن‌دار بدون جهت
\lr{$ \graph = \left( \vertices, \edges \right) $}
مدل می‌شود. تمامی مجموعه‌ی چند‌تایی‌های
\lr{$ \tuples $}
که درون پایگاه‌داده‌ی رابطه‌ای جای گرفته‌اند، یک به یک بر مجموعه‌ی گره‌های گراف
\lr{$ \graph $}
نگاشت می‌شوند و مجموعه‌ی گره‌های گراف را تشکیل می‌دهند که در رابطه‌ی
\ref{equation:graph-vertices}
تشکیل می‌دهد. بدیهی است که تعداد کل گره‌های گراف با تعداد کل چند‌تایی‌ها یا همان
\lr{$ \numberOfTuples $}
برابر خواهد بود.

\begin{latin}
	\begin{equation} \label{equation:graph-vertices}
		\vertices = \left \{ \vertex_{1}, \vertex_{2}, ..., \vertex_{\numberOfTuples} \right \}
	\end{equation}
\end{latin}

\paragraph*{}
در ادامه خواهیم دید که تابع هدف الگوریتم بخش‌بندی ارائه شده، به طور دقیق برابر خواهد بود با تعداد تراکنش‌های توزیعی موجود ذخیره شده درون سامانه‌ی پایگاه‌داده‌ی توزیعی؛ یا همان مقدار
\lr{$ |\distributedTransactions| $}
که همانطور که در معادله‌ی
\ref{equation:performance}
نشان داده شد، تابع هدف می‌بایست با کمینه کردن تعداد تراکنش‌های توزیعی هم ارز باشد. پس بنابراین در طول اجرای الگوریتم بخش‌بندی، هدف کمینه کردن مقدار
\lr{$ |\distributedTransactions| $}
یا همان مقدار تابع هدف است.

\paragraph*{}
در محاسبه‌ی تابع هدف در هر دور از اجرای الگوریتم، نیاز است که هر گره (یا همان چندتایی پایگاه‌داده) اطلاعاتی از همسایگان خود داشته باشد. پس این الزام وجود دارد که هر گره امکان شناسایی همسایگان خود را به نحوی داشته باشد. مدل الگوریتم بهترین روش برای شناسایی همسایگان گره‌ی گراف و نگاشت آن‌ها به آن گره خواهد بود. پس روشی که به ذهن می‌رسد این است که میان هر دو گره‌ای که حداقل در یک تراکنش با یکدیگر مورد دسترسی قرار می‌گیرند، یک یال ترسیم گردد.

\paragraph*{}
نکته‌ای که حائز اهمیت است این است که امکان دارد حجم ذخیره‌ای چندتایی‌های ذخیره شده در پایگاه‌داده نسبت به یکدیگر متفاوت باشند. به عنوان مثال برای ذخیره‌ی یک چندتایی به خصوص، چندین برابر چندتایی‌های دیگر، فضای حافظه مورد نیاز باشد. برای اینکه این نکته نیز در مدل دخیل شود، برای گره‌های متناظر هر یک از این چندتایی‌ها، یک عدد وزن نسبی نیز در نظر گرفته می‌شود. بدیهی است که توزیع بار یکسان گره‌ها بر روی سرویس‌دهنده‌های پایگاه‌داده، با توجه به این وزن‌ها صورت می‌گیرد و از این جهت بود که در ابتدای این بخش، گراف وزن‌دار تلقی گردید.


\section{الگوریتم بخش‌بندی حجم کار}
\subsection{تابع هدف الگوریتم بخش‌بندی}

\section{معماری پیشنهادی}